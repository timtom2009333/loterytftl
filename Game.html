<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Двоичная игра(соло)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <style>
    :root {
      --rows: 7;
      --gap: 10px;
      --pc-max-w: 1000px;

      /* Тёмная тема — базовая */
      --bg: #0f3e52;
      --panel: #083a4a;
      --panel-border: #0a4a5e;
      --header-bg: #0c4f63;
      --header-border: #115e75;
      --hud-bg: #0b4a5c;
      --hud-border: #0f5b73;
      --text: #d6f2ff;
      --bit-off-bg: #0b5a72;
      --bit-off-border: #6de28f;
      --bit-on-bg: #63c66b;
      --bit-on-border: #63c66b;
      --bit-on-text: #0d2a1a;
      --task-bg-1: #0c4a5d;
      --task-bg-2: #0c4a5d;
      --success: #63c66b;
      --accent: #21b7f0;
      --danger-bg: #ffcccc;
      --score: #10b981;
      --pad-bg: #ffb74d;
      --pad-ok: #0d3140;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
      overflow: hidden;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      outline: none;
    }

    header { text-align: center; padding: 8px 10px; background: var(--header-bg); border-bottom: 1px solid var(--header-border); }
    header h1 { margin: 0; font-size: 20px; }

    .layout { height: 100svh; display: flex; flex-direction: column; }

    .hud { flex: 0 0 auto; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px; padding: 10px; background: var(--hud-bg); border-bottom: 2px solid var(--hud-border); order: -1; }
    .badge { padding: 8px 12px; border-radius: 8px; background: #0a5670; border: 1px solid #15718b; font-weight: 800; color: #d6f2ff; }
    .badge.score.flash { animation: score-flash .3s ease-in-out; }
    @keyframes score-flash { 0% { transform: scale(1); background: #0a5670; } 50% { transform: scale(1.06); background: #0d8a66; } 100% { transform: scale(1); background: #0a5670; } }

    .btn { appearance: none; border: 1px solid #1584a2; border-radius: 8px; background: var(--accent); color: #002433; padding: 10px 16px; font-weight: 800; cursor: pointer; letter-spacing: .3px; -webkit-tap-highlight-color: transparent; outline: none; }

    .stage { flex: 1 1 auto; min-height: 0; display: flex; align-items: center; justify-content: center; padding: 8px; overflow: hidden; background: #094457; }

    .game { width: 100%; height: 100%; max-width: var(--pc-max-w); background: var(--panel); border: 1px solid var(--panel-border); border-radius: 12px; padding: 8px; box-shadow: 0 8px 24px rgba(0,0,0,.18); display: flex; flex-direction: column; overflow: hidden; }

    /* Внутри board рассчитываем размер «условной строки» */
    .board { flex: 1 1 auto; min-height: 0; display: flex; flex-direction: column; gap: var(--gap); --row-size: calc((100% - var(--rows) * var(--gap)) / (var(--rows) + 1)); }

    /* Делаем хедер чуть ниже, чем 1 строка — так место уходит в пользу задач */
    .grid-header { flex: 0 0 calc(var(--row-size) * .66); display: flex; align-items: center; gap: var(--gap); background: #0a4f64; border: 1px solid #0f5b73; border-radius: 10px; padding: 0 var(--gap); color: #bfefff; font-weight: 800; }
    .power { flex: 1 1 0; display: flex; align-items: center; justify-content: center; height: 70%; background: #0b5c73; border: 1px solid #0f6b86; border-radius: 8px; }

    .eq-head {
      flex: 0 0 auto;
      display: flex; align-items: center; justify-content: center;
      height: 70%;
      background: transparent; border: none; border-radius: 0;
      padding: 0;
      inline-size: 1.25ch;
      color: #bfefff;
      font-weight: 900; font-size: 14px; line-height: 1;
    }

    .dec-head { flex: 0 0 12%; display: flex; align-items: center; justify-content: center; height: 70%; background: #0b5c73; border: 1px solid #0f6b86; border-radius: 8px; }

    .hints-hidden .power span,
    .hints-hidden .eq-head span,
    .hints-hidden .dec-head span { visibility: hidden; }

    .tasks { flex: 1 1 auto; min-height: 0; position: relative; background: #0a4a5f; border: 1px solid #0f5b73; border-radius: 10px; padding: 0 var(--gap); overflow: hidden; }
    @keyframes danger-flash { 0%, 100% { background-color: #0a4a5f; } 50% { background-color: var(--danger-bg); } }
    .tasks.danger { animation: danger-flash .6s linear infinite; box-shadow: 0 0 0 3px rgba(255,59,48,.25) inset; }

    .task { position: absolute; left: var(--gap); right: var(--gap); display: flex; align-items: center; gap: var(--gap); padding: 0 var(--gap); border-radius: 10px; border: 1px solid #0f5b73; background: #0a4a5f; color: #d6f2ff; transition: background .15s ease, bottom .3s ease; height: calc((100% - (var(--rows) - 1) * var(--gap)) / (var(--rows))); }

    .bit {
      flex: 1 1 0;
      height: 92%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; user-select: none;
      border-radius: 12px;
      background: var(--panel);
      border: 2px solid var(--bit-off-border);
      font-weight: 800; color: #8feaa7;
      -webkit-tap-highlight-color: transparent; outline: none;
      font-size: clamp(12px, 1.4vw, 28px);
    }
    .bit.on { background: var(--bit-on-bg); color: var(--bit-on-text); border-color: var(--bit-on-border); }
    .bit.locked { pointer-events: none; opacity: 1; }
    .bit.pressed { transform: translateY(1px) scale(0.99); filter: brightness(0.97); } /* визуальный отклик */

    .eq{
      flex: 0 0 auto;
      display: flex; align-items: center; justify-content: center;
      height: 90%;
      background: transparent; border: none; border-radius: 0;
      padding: 0;
      inline-size: 1.25ch;
      font-weight: 900; color:#7ed0f8;
      font-size: clamp(10px, .9vw, 16px);
      line-height: 1;
    }

    .target {
      flex: 0 0 10%;
      height: 90%;
      display: flex; align-items: center; justify-content: center;
      border-radius: 12px; background: #ffd166; color: #0b3342;
      border: 2px solid #ffe5a5; font-weight: 900; -webkit-tap-highlight-color: transparent; outline: none;
      padding: 0 6px;
    }
    .target.q { cursor: pointer; }

    .score-fx { position: absolute; pointer-events: none; font-weight: 900; text-shadow: 0 2px 10px rgba(0,0,0,.15); opacity: 0; animation: score-pop .8s ease-out forwards; }
    .score-fx.points { color: var(--score); }
    @keyframes score-pop { 0% { transform: translateY(10px) scale(.92); opacity: 0; } 15% { opacity: 1; } 100% { transform: translateY(-28px) scale(1); opacity: 0; } }

    @media (min-width: 900px) {
      .layout { flex-direction: row; }
      .stage  { order: 1; flex: 1; }
      .hud { order: 2; width: 300px; flex-direction: column; align-items: stretch; justify-content: flex-start; border-left: 2px solid var(--hud-border); border-bottom: none; }
      .game { width: 100%; height: 100%; max-width: var(--pc-max-w); }

      .power { flex: 1 1 0; height: 70%; }
      .eq-head { height: 70%; font-size: 13px; inline-size: 1.25ch; }
      .dec-head { flex: 0 0 12%; height: 70%; }

      .bit { flex: 1 1 0; height: 92%; font-size: clamp(12px, 1.4vw, 28px); }
      .eq  { height: 90%; font-size: clamp(10px, .9vw, 16px); inline-size: 1.25ch; }
      .target { flex: 0 0 10%; height: 90%; font-size: clamp(13px, 1.2vw, 24px); }
    }

    .overlay { position: fixed; inset: 0; background: rgba(0,0,0,.55); display: none; align-items: center; justify-content: center; z-index: 999; }
    .overlay.show { display: flex; }
    .overlay-card { background: #0c4f63; color:#d6f2ff; border-radius: 14px; border: 1px solid #14728e; padding: 18px 16px; width: min(520px, 92vw); text-align: center; box-shadow: 0 10px 26px rgba(0,0,0,.35); }
    .overlay-card h2 { margin: 0 0 8px; font-size: 22px; }
    .overlay-card p  { margin: 0 0 14px; opacity:.9; font-size: 15px; }
    .overlay-card .btn-primary { background: var(--accent); color: #002433; border: none; border-radius: 10px; padding: 10px 18px; font-weight: 800; cursor: pointer; font-size: 16px; }

    .numpad { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: transparent; z-index: 1500; }
    .numpad.show { display:flex; }
    .pad { position: fixed; top: 0; left: 0; background:#0c4f63; border:1px solid #14728e; width:min(240px,92vw); border-radius:14px; box-shadow:0 10px 26px rgba(0,0,0,.35); padding:10px; }
    .pad-display { height:44px; border-radius:12px; border:2px solid #ffe5a5; background:#ffd166; color:#0b3342; display:flex; align-items:center; justify-content:flex-end; padding:0 12px; font-weight:900; font-size:20px; }
    .pad-grid { margin-top:10px; display:grid; grid-template-columns:repeat(3,1fr); gap:8px; }
    .pad-btn { background: var(--pad-bg); color:#0b3342; font-weight:900; border:none; border-radius:14px; padding:12px 0; cursor:pointer; font-size:16px; }
    .pad-btn.ok { background:#ffd166; color:#0b3342; border:3px solid var(--pad-ok); }
    .pad-btn.back { position:relative; }
    .pad-btn.back::before { content:'⌫'; font-weight:900; }
    .pad-err { animation: padErr .15s ease-in-out 0s 2; }
    @keyframes padErr { from{transform:translateX(-3px)} to{transform:translateX(3px)} }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #F6F8FB;
        --text: #1F2937;
        --panel: #FFFFFF;
        --panel-border: #E5EAF1;

        --header-bg: #EEF3FF;
        --header-border: #D7E3FF;
        --hud-bg: #F3F6FB;
        --hud-border: #E5EAF1;

        --task-bg-1: #FFFFFF;
        --task-bg-2: #F9FBFF;

        --bit-off-bg: #F3F6FB;
        --bit-off-border: #D6DFEA;
        --bit-on-bg: #3B82F6;
        --bit-on-border: #3B82F6;
        --bit-on-text: #0B2D1F;

        --accent: #3B82F6;
        --score: #10B981;
      }

      body { color: var(--text); background: var(--bg); }
      .badge { background:#EFF3F8; border:1px solid #DFE6EF; color:#374151; }

      .grid-header { flex: 0 0 calc(var(--row-size) * .66); background: var(--header-bg); border-color: var(--header-border); color:#15324B; }
      .power, .dec-head { background:#F7FAFF; border:1px solid #E6EEFF; }
      .eq-head { background: transparent; border: none; color:#2E6F8A; }

      .tasks { background:#F7FAFF; border-color:#E5EDF7; }
      .task { background: var(--task-bg-1); border:1px solid #E6ECF5; color:#1F2937; }
      .task:nth-child(even) { background: var(--task-bg-2); }

      .bit { background: var(--panel); border-color: var(--bit-off-border); color:#415367; }
      .bit.on { background: var(--bit-on-bg); color: var(--bit-on-text); border-color: var(--bit-on-border); }

      .eq { background: transparent; border: none; color:#2E6F8A; }

      .target { background:#FFE8A3; border-color:#FFD66E; color:#2D3A3F; }

      .btn { background: var(--accent); color:#FFFFFF; border-color:#3B82F6; }
      .btn:hover { filter: brightness(1.05); }

      .overlay-card { background:#FFFFFF; color:#1F2937; border:1px solid #DFE6EF; }

      .pad { background:#FFFFFF; border:1px solid #DEE7F2; box-shadow:0 10px 26px rgba(15, 23, 42, .06); }
      .pad-display { background:#FFF2B3; border:2px solid #FFE28A; color:#1F2937; }
      .pad-btn { background:#EAF2FF; color:#0B2540; }
      .pad-btn.ok { background: var(--accent); color:#FFFFFF; border-color:#1D4ED8; }
      .pad-btn.back { background:#EFF3F8; }
    }

    @media (max-width: 899px) {
      .stage, .game, .grid-header, .tasks { padding-left: 0; padding-right: 0; }
      .task { left: 0; right: 0; gap: var(--gap); }
      :root { --gap: 3px; }
      .bit {
        font-size: clamp(16px, 5.5vw, 32px);
        flex: 1 1 0;
        min-width: 0;
        margin: 0 !important;
        box-sizing: border-box;
        height: 92%;
      }
      .eq { inline-size: 1.25ch; font-size: 14px; }
      .eq-head { inline-size: 1.25ch; font-size: 14px; }
      .target { flex-basis: 10%; }
    }
  </style>
</head>
<body>
<script>
  document.addEventListener('dblclick', function (e) { e.preventDefault(); }, { passive: false });
  window.addEventListener('wheel', function (e) { if (e.ctrlKey) e.preventDefault(); }, { passive: false });
  document.addEventListener('gesturestart', function (e) { e.preventDefault(); }, { passive: false });
</script>

  <header><h1>Двоичная игра</h1></header>

  <div class="layout" id="layout">
    <div class="stage">
      <div class="game">
        <div class="board" id="board">
          <div class="grid-header" id="header">
            <div class="power"><span>128</span></div>
            <div class="power"><span>64</span></div>
            <div class="power"><span>32</span></div>
            <div class="power"><span>16</span></div>
            <div class="power"><span>8</span></div>
            <div class="power"><span>4</span></div>
            <div class="power"><span>2</span></div>
            <div class="power"><span>1</span></div>
            <div class="eq-head"><span>=</span></div>
            <div class="dec-head"><span>255</span></div>
          </div>
          <div class="tasks" id="tasks"></div>
        </div>
      </div>
    </div>
    <aside class="hud">
      <div class="badge score">Очки: <span id="score">0</span></div>
      <div class="badge">Уровень: <span id="level">1</span></div>
      <div class="badge">Строк: <span id="linesLeft">0/7</span></div>
      <button class="btn" id="restartBtn">Новая игра</button>
    </aside>
  </div>

  <div class="overlay" id="overlay">
    <div class="overlay-card">
      <h2 id="ovTitle">Добро пожаловать</h2>
      <p id="ovText">Нажмите «Старт», чтобы начать игру.</p>
      <button class="btn-primary" id="ovBtn">Старт</button>
    </div>
  </div>

  <div class="numpad" id="numpad" aria-hidden="true">
    <div class="pad">
      <div class="pad-display" id="padDisplay">&nbsp;</div>
      <div class="pad-grid">
        <button class="pad-btn" data-key="7">7</button>
        <button class="pad-btn" data-key="8">8</button>
        <button class="pad-btn" data-key="9">9</button>
        <button class="pad-btn" data-key="4">4</button>
        <button class="pad-btn" data-key="5">5</button>
        <button class="pad-btn" data-key="6">6</button>
        <button class="pad-btn" data-key="1">1</button>
        <button class="pad-btn" data-key="2">2</button>
        <button class="pad-btn" data-key="3">3</button>
        <button class="pad-btn back" data-key="back"></button>
        <button class="pad-btn" data-key="0">0</button>
        <button class="pad-btn ok" data-key="ok">OK</button>
      </div>
    </div>
  </div>

  <script>
    const layoutEl    = document.getElementById('layout');
    const headerElTop = document.querySelector('header');
    function fitLayoutHeight(){ const hh=headerElTop.offsetHeight||0; layoutEl.style.height=`calc(100svh - ${hh}px)` }
    window.addEventListener('load', fitLayoutHeight); window.addEventListener('resize', fitLayoutHeight); window.addEventListener('orientationchange', fitLayoutHeight);

    const POWERS=[128,64,32,16,8,4,2,1];
    const MAX_ROWS=7;
    const HOLD_MS = 20; // регистрируем только удержание > 20 мс

    const CONFIG={ level2AtScore:1200, level3AtScore:2800, level4AtScore:4800, level5AtScore:7200, pointsPerTask:100, reverseRowProb:0.30 };

    const POOLS={
      L1:[1,2,3,4,7,8,15,16,17,31,32,34,51,63,64,68,85,102,119,127,128,136,160,176,192,204,224,240,248,252,254,255],
      L2:[5,6,9,10,12,18,20,24,33,36,40,48,56,65,66,72,80,88,96,104,112,120,129,130,132,144,152,153,168,170,184,191,200,208,216,221,223,232,239,247,251,253],
      L3:[11,13,14,19,23,25,27,28,29,30,35,39,47,49,55,57,59,60,61,62,67,71,79,97,99,103,113,115,121,124,126,131,134,135,140,142,143,156,158,159,188,193,194,195,196,198,199,206,207,220,225,226,227,228,230,231,241,243,249],
      L4:[21,22,26,37,38,44,46,50,52,54,58,70,76,78,92,94,95,98,100,108,110,111,114,116,118,122,123,125,133,137,139,141,145,147,151,155,157,161,163,167,177,179,185,190,197,201,203,205,209,211,217,222,229,233,236,238,242,244,246,250],
      L5H:[41,42,43,45,53,69,73,74,75,77,81,82,83,84,86,87,89,90,91,93,101,105,106,107,109,117,138,146,148,149,150,154,162,164,165,166,169,171,172,173,174,175,178,180,181,182,183,186,187,189,202,210,212,213,214,215,218,219,234,235,237,245]
    };
    POOLS.L5=[...POOLS.L4,...POOLS.L5H];

    const LEVELS=[
      {id:1,interval:10000,hints:true,name:'Уровень 1'},
      {id:2,interval:8000,hints:true,name:'Уровень 2'},
      {id:3,interval:7000,hints:false,name:'Уровень 3'},
      {id:4,interval:5500,hints:false,name:'Уровень 4'},
      {id:5,interval:4500,hints:false,name:'Уровень 5'}
    ];

    const tasksEl=document.getElementById('tasks');
    const headerEl=document.getElementById('header');
    const scoreEl=document.getElementById('score');
    const levelEl=document.getElementById('level');
    const linesEl=document.getElementById('linesLeft');
    const overlay=document.getElementById('overlay');
    const ovTitle=document.getElementById('ovTitle');
    const ovText=document.getElementById('ovText');
    let ovBtn=document.getElementById('ovBtn');
    const restartBtn=document.getElementById('restartBtn');

    let score=0; let currentLevel=1; let spawnTimer=null; let gameOver=false; let paused=true;
    let dangerActive=false; let dangerTimeout=null; let slots=new Array(MAX_ROWS).fill(false);
    let forceStandardCount=0;
    let activeTargets = new Set();

    function poolForLevel(level){ if(level===1)return POOLS.L1; if(level===2)return POOLS.L2; if(level===3)return POOLS.L3; if(level===4)return POOLS.L4; return POOLS.L5; }
    function randTarget(level){ const pool=poolForLevel(level); return pool[Math.floor(Math.random()*pool.length)] }
    function randUniqueTarget(level) {
      const pool = poolForLevel(level);
      const free = pool.filter(n => !activeTargets.has(n));
      // fallback к pool если вдруг всё занято
      const base = free.length ? free : pool;
      return base[Math.floor(Math.random() * base.length)];
    }
    function rowValue(row){ const bits=[...row.querySelectorAll('.bit')]; return bits.reduce((s,b,i)=>s+(b.classList.contains('on')?POWERS[i]:0),0) }
    function setHud(){ scoreEl.textContent=String(score); levelEl.textContent=String(currentLevel); linesEl.textContent=`${tasksEl.childElementCount}/${MAX_ROWS}`; headerEl.classList.toggle('hints-hidden',!LEVELS[currentLevel-1].hints) }
    function clearSpawn(){ if(spawnTimer){ clearTimeout(spawnTimer); spawnTimer=null } }
    function scheduleSpawn(){ clearSpawn(); if(paused||gameOver||dangerActive)return; const interval=LEVELS[currentLevel-1].interval; spawnTimer=setTimeout(()=>{ addTask(); scheduleSpawn() },interval) }

    function burstSpawnOnClear() {
      if (paused || gameOver || dangerActive) return;
      const hasTasks = !!tasksEl.querySelector('.task');
      if (hasTasks) return;
      const n = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < n; i++) addTask();
      scheduleSpawn();
    }

    function resetDanger(){ dangerActive=false; tasksEl.classList.remove('danger'); if(dangerTimeout){ clearTimeout(dangerTimeout); dangerTimeout=null } scheduleSpawn(); setHud() }
    function enterDanger(){ if(dangerActive||gameOver)return; dangerActive=true; clearSpawn(); tasksEl.classList.add('danger'); dangerTimeout=setTimeout(()=>{ if(dangerActive) endGame() },5000) }
    function getGapPx(){ const g=getComputedStyle(document.documentElement).getPropertyValue('--gap'); return parseFloat(g)||0 }
    function getRowH(){ const g=getGapPx(); return (tasksEl.clientHeight-((MAX_ROWS-1)*g))/MAX_ROWS }
    function placeRow(row,slot){ const g=getGapPx(); const h=getRowH(); row.style.bottom=`${slot*(h+g)}px`; row.style.height=`${h}px` }
    function firstFreeSlot(){ return slots.indexOf(false) }
    function awardPoints(amount,anchorEl){ score+=amount; setHud(); const badge=scoreEl.closest('.badge'); if(badge){ badge.classList.add('flash'); setTimeout(()=>badge.classList.remove('flash'),300) } if(anchorEl){ const r1=anchorEl.getBoundingClientRect(); const r2=tasksEl.getBoundingClientRect(); const x=r1.left+r1.width/2-r2.left+(Math.random()*20-10); const y=r1.top+r1.height/2-r2.top+(Math.random()*10-5); const fx=document.createElement('div'); fx.className='score-fx points'; fx.textContent=`+${amount}`; fx.style.left=`${x}px`; fx.style.top=`${y}px`; tasksEl.appendChild(fx); fx.addEventListener('animationend',()=>fx.remove()) } }

    function compactFromSlot(removedSlot){
      const rows=[...tasksEl.querySelectorAll('.task')];
      for(const r of rows){
        const rs=parseInt(r.dataset.slot,10);
        if(rs>removedSlot){
          const ns=rs-1;
          r.dataset.slot=String(ns);
          placeRow(r,ns);
        }
      }
      for(let i=removedSlot;i<MAX_ROWS-1;i++){ slots[i]=slots[i+1]; }
      slots[MAX_ROWS-1]=false;
    }

    const numpad=document.getElementById('numpad');
    const padDisplay=document.getElementById('padDisplay');
    const padEl=numpad.querySelector('.pad');
    let padBuffer=''; let padOnSubmit=null; let padAnchorEl=null;
    function positionPad(anchor){ if(!anchor) return; const ar=anchor.getBoundingClientRect(); const pr=padEl.getBoundingClientRect(); let x=ar.right+8; let y=ar.top; if(x+pr.width>window.innerWidth-8) x=Math.max(8,ar.left-pr.width-8); if(y+pr.height>window.innerHeight-8) y=Math.max(8,window.innerHeight-pr.height-8); padEl.style.transform=`translate(${Math.round(x)}px, ${Math.round(y)}px)` }
    function openPad(onSubmit,initial='',anchor=null){ padBuffer=initial; padOnSubmit=onSubmit; padAnchorEl=anchor; padDisplay.textContent=padBuffer||'\u00A0'; numpad.classList.add('show'); requestAnimationFrame(()=>positionPad(padAnchorEl)) }
    function closePad(){ numpad.classList.remove('show') }

    numpad.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-key]');
      if (btn) {
        const k = btn.dataset.key;
        if (k === 'back') {
          padBuffer = padBuffer.slice(0, -1);
        } else if (k === 'ok') {
          const n = padBuffer === '' ? NaN : parseInt(padBuffer, 10);
          if (Number.isNaN(n) || n < 1 || n > 255) {
            padDisplay.classList.add('pad-err');
            setTimeout(() => padDisplay.classList.remove('pad-err'), 150);
          } else {
            if (typeof padOnSubmit === 'function') padOnSubmit(n);
            closePad();
          }
        } else {
          if (k === '0' && padBuffer.length === 0) {
            padDisplay.classList.add('pad-err');
            setTimeout(() => padDisplay.classList.remove('pad-err'), 150);
          } else if (padBuffer.length < 3) {
            padBuffer += k;
          }
        }
        padDisplay.textContent = padBuffer || '\u00A0';
      }
    });

    document.addEventListener('click',(e)=>{
      const clickedPad=!!e.target.closest('.pad');
      const clickedQ=!!e.target.closest('.target.q');
      if(numpad.classList.contains('show') && !clickedPad && !clickedQ){ closePad() }
    });
    document.addEventListener('keydown',(e)=>{ if(e.key==='Escape') closePad() });
    window.addEventListener('resize',()=>positionPad(padAnchorEl));
    window.addEventListener('orientationchange',()=>positionPad(padAnchorEl));
    window.addEventListener('scroll',()=>positionPad(padAnchorEl),true);

    function addTask(options={}){
      if(gameOver||paused||dangerActive) return;
      const slot=firstFreeSlot(); if(slot===-1){ enterDanger(); } else {
        let isReverse = (typeof options.type==='string') ? (options.type==='reverse') : (Math.random()<CONFIG.reverseRowProb);
        if(forceStandardCount>0){ isReverse=false; forceStandardCount--; }
        const num = randUniqueTarget(currentLevel);
        const row=document.createElement('div'); row.className='task'; row.dataset.slot=String(slot); row.dataset.type=isReverse?'reverse':'standard';
        for(let i=0;i<8;i++){
          const bit=document.createElement('div'); bit.className='bit'; bit.textContent='0';
          if(isReverse){ if(num & POWERS[i]){ bit.classList.add('on'); bit.textContent='1' } bit.classList.add('locked') }
          else {
            let downAt = 0;
            bit.addEventListener('pointerdown', (e) => {
              if (gameOver || paused) return;
              downAt = performance.now();
              bit.classList.add('pressed');
            });
            bit.addEventListener('pointerup', (e) => {
              bit.classList.remove('pressed');
              if (gameOver || paused) return;
              const dt = performance.now() - downAt;
              if (dt >= HOLD_MS) {
                bit.classList.toggle('on');
                bit.textContent = bit.classList.contains('on') ? '1' : '0';
                if (rowValue(row) === num) resolveRow(row, num);
              }
            });
            bit.addEventListener('pointercancel', () => bit.classList.remove('pressed'));
            bit.addEventListener('pointerleave',  () => bit.classList.remove('pressed'));
          }
          row.appendChild(bit)
        }
        const eq=document.createElement('div'); eq.className='eq'; eq.textContent='='; row.appendChild(eq);
        const target=document.createElement('div'); target.className='target'+(isReverse?' q':''); target.textContent=isReverse?'?':String(num); row.appendChild(target);
        if(isReverse){
          target.addEventListener('click',()=>{
            if(numpad.classList.contains('show')){ closePad(); }
            else { openPad((val)=>{ if(val===num) resolveRow(row,num); else { padDisplay.classList.add('pad-err'); setTimeout(()=>padDisplay.classList.remove('pad-err'),150) } },'',target) }
          })
        }
        tasksEl.appendChild(row);

        row.dataset.target = String(num);
        activeTargets.add(num);

        if (!isReverse) {
          const bitsEls = [...row.querySelectorAll('.bit')];
          const zeroIdx = [];
          for (let i = 0; i < 8; i++) if ((num & POWERS[i]) === 0) zeroIdx.push(i);
          let k = Math.floor(Math.random() * 4); // 0..3
          if (k > zeroIdx.length) k = zeroIdx.length;
          for (let t = 0; t < k; t++) {
            const pickIndex = Math.floor(Math.random() * zeroIdx.length);
            const pick = zeroIdx.splice(pickIndex, 1)[0];
            const b = bitsEls[pick];
            b.classList.add('on');
            b.textContent = '1';
          }
        }
        slots[slot]=true; placeRow(row,slot); setHud(); if(tasksEl.childElementCount>=MAX_ROWS) enterDanger();
      }
    }

    function resolveRow(row,num){
      row.style.background='var(--success)';
      setTimeout(()=>{
        const s=parseInt(row.dataset.slot,10);
        const anchor=row.querySelector('.target')||row;
        const targetNum = Number(row.dataset.target);
        if (!Number.isNaN(targetNum)) activeTargets.delete(targetNum);
        row.remove();
        slots[s]=false;
        compactFromSlot(s);
        if(dangerActive && tasksEl.childElementCount<MAX_ROWS) resetDanger();
        setHud();
        awardPoints(CONFIG.pointsPerTask, anchor);
        tryLevelUp();
        burstSpawnOnClear();
      },120);
    }

    function clearField(){
      tasksEl.innerHTML='';
      slots=new Array(MAX_ROWS).fill(false);
      setHud();
      activeTargets.clear();
    }

    function showOverlay({title,text,btnText,onConfirm}){
      ovTitle.textContent=title; ovText.textContent=text; ovBtn.textContent=btnText; overlay.classList.add('show');
      const newBtn=ovBtn.cloneNode(true); ovBtn.parentNode.replaceChild(newBtn,ovBtn); ovBtn=newBtn;
      ovBtn.addEventListener('click',()=>{ overlay.classList.remove('show'); if(typeof onConfirm==='function') onConfirm() })
    }
    function endGame(){ gameOver=true; clearSpawn(); resetDanger(); showOverlay({ title:'Игра окончена', text:`Игровое поле переполнено. Очки: ${score}`, btnText:'Играть снова', onConfirm:()=>{ newGame() } }) }
    function levelOverlay(){ const L=LEVELS[currentLevel-1]; showOverlay({ title:L.name, text: currentLevel>=3? 'Подсказки скрыты. Продолжайте!' : 'Становится быстрее. Готовы?', btnText:'Продолжить', onConfirm:()=>{ paused=false; forceStandardCount=2; addTask({type:'standard'}); addTask({type:'standard'}); scheduleSpawn() } }) }
    function tryLevelUp(){ const prev=currentLevel; if(score>=CONFIG.level5AtScore) currentLevel=5; else if(score>=CONFIG.level4AtScore) currentLevel=4; else if(score>=CONFIG.level3AtScore) currentLevel=3; else if(score>=CONFIG.level2AtScore) currentLevel=2; else currentLevel=1; if(currentLevel!==prev){ paused=true; clearSpawn(); resetDanger(); clearField(); setHud(); levelOverlay() } }
    function newGame(){ gameOver=false; paused=false; resetDanger(); score=0; currentLevel=1; forceStandardCount=2; clearField(); setHud(); addTask({type:'standard'}); addTask({type:'standard'}); scheduleSpawn() }
    restartBtn.addEventListener('click',()=>{ paused=true; clearSpawn(); resetDanger(); showOverlay({ title:'Новая игра', text:'Начать заново?', btnText:'Старт', onConfirm:()=>{ newGame() } }) })
    showOverlay({ title:'Добро пожаловать', text:'Нажмите «Старт» для начала игры.', btnText:'Старт', onConfirm:()=>{ newGame() } })
    setHud();
    window.addEventListener('resize',()=>{ [...tasksEl.querySelectorAll('.task')].forEach(row=>{ placeRow(row,parseInt(row.dataset.slot,10)) }); positionPad(padAnchorEl) });

    const rotateOverlay=document.createElement('div'); rotateOverlay.style.cssText='position:fixed;inset:0;z-index:2000;background:rgba(0,0,0,.85);color:#fff;display:none;align-items:center;justify-content:center;text-align:center;font-size:20px;font-weight:900;padding:24px;'; rotateOverlay.textContent='Поверните телефон вертикально'; document.body.appendChild(rotateOverlay);
    const MIN_ROW_H=40; function hasEnoughSpace(){ const g=getGapPx(); const available=tasksEl.clientHeight; const rowH=(available-((MAX_ROWS-1)*g))/MAX_ROWS; return rowH>=MIN_ROW_H }
    function checkOrientationAndSpace(){ const isLandscape=window.matchMedia('(orientation: landscape)').matches; rotateOverlay.style.display=(isLandscape && !hasEnoughSpace())?'flex':'none' }
    window.addEventListener('load',checkOrientationAndSpace); window.addEventListener('resize',()=>{ [...tasksEl.querySelectorAll('.task')].forEach(row=>{ placeRow(row,parseInt(row.dataset.slot,10)) }); checkOrientationAndSpace() }); window.addEventListener('orientationchange',checkOrientationAndSpace);
    const _newGameRef=newGame; newGame=function(){ _newGameRef(); checkOrientationAndSpace() };
    const _levelOverlayRef=levelOverlay; levelOverlay=function(){ _levelOverlayRef(); setTimeout(checkOrientationAndSpace,0) };
  </script>
</body>
</html>
